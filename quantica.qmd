# Introdu√ß√£o √† Computa√ß√£o Qu√¢ntica usando `Qiskit`

-- William W. T. Rodrigues <br>
<williamwallace@alunos.utfpr.edu.br>

> __Resumo:__
> Este minicurso apresenta uma introdu√ß√£o √† computa√ß√£o qu√¢ntica, explorando seus fundamentos te√≥ricos, arquiteturas f√≠sicas de qubits, algoritmos relevantes e aplica√ß√µes pr√°ticas. Utilizando o framework Qiskit da IBM, o curso combina conceitos da mec√¢nica qu√¢ntica com exemplos de programa√ß√£o, permitindo ao leitor construir e simular circuitos qu√¢nticos. 


## Introdu√ß√£o {#sec-quant-intro}

A computa√ß√£o qu√¢ntica √© um paradigma de processamento de informa√ß√£o baseado diretamente nos princ√≠pios da mec√¢nica qu√¢ntica, ramo da f√≠sica que descreve o comportamento da mat√©ria e da energia em escalas extremamente pequenas, como √°tomos, el√©trons e f√≥tons.  
Assim como a f√≠sica qu√¢ntica introduziu conceitos contraintuitivos como superposi√ß√£o, entrela√ßamento e dualidade onda-part√≠cula, a computa√ß√£o qu√¢ntica aproveita esses fen√¥menos para processar informa√ß√µes de maneiras que n√£o t√™m equivalente direto no mundo cl√°ssico.

Nos computadores tradicionais, a unidade b√°sica de informa√ß√£o √© o *bit*, que s√≥ pode assumir um de dois valores: 0 ou 1. J√° na computa√ß√£o qu√¢ntica, a unidade √© o *qubit* (*quantum bit*), que pode existir n√£o apenas nos estados cl√°ssicos \(|0\rangle\) ou \(|1\rangle\), mas tamb√©m em qualquer combina√ß√£o linear deles, chamada superposi√ß√£o. Isso significa que um qubit pode representar 0 e 1 ao mesmo tempo, com diferentes amplitudes de probabilidade.

Fisicamente, um qubit n√£o √© apenas um conceito abstrato: ele precisa ser implementado em um sistema f√≠sico real capaz de apresentar comportamento qu√¢ntico. Entre as implementa√ß√µes mais comuns est√£o:  
- *Qubits* supercondutores ‚Äì correntes el√©tricas oscilando em circuitos supercondutores a temperaturas pr√≥ximas do zero absoluto (usados pela IBM e Google).  
- *Qubits* de √≠ons aprisionados ‚Äì √≠ons individuais suspensos no v√°cuo e manipulados com feixes de *laser* (IonQ, Honeywell).  
- *Qubits* fot√¥nicos ‚Äì f√≥tons individuais, codificando informa√ß√£o em sua polariza√ß√£o ou caminho (Xanadu, PsiQuantum).  
- *Qubits de spin* ‚Äì baseados no spin de el√©trons aprisionados em semicondutores ou defeitos em diamantes (NV centers).  

Independentemente da implementa√ß√£o f√≠sica, todos compartilham as mesmas propriedades fundamentais:  
- Superposi√ß√£o ‚Äì capacidade de estar em m√∫ltiplos estados ao mesmo tempo.  
- Entrela√ßamento ‚Äì correla√ß√£o profunda entre qubits que persiste mesmo quando est√£o fisicamente separados.  
- Interfer√™ncia ‚Äì manipula√ß√£o das amplitudes de probabilidade para refor√ßar resultados corretos e cancelar resultados incorretos.  

Essa diferen√ßa fundamental se traduz no espa√ßo de estados dispon√≠vel: enquanto um processador cl√°ssico com \(n\) bits s√≥ pode representar um estado por vez, um processador qu√¢ntico com \(n\) qubits pode manipular simultaneamente \(2^n\) estados, explorando um paralelismo exponencial que pode oferecer vantagens significativas para certos problemas, como simula√ß√£o de sistemas qu√¢nticos, criptografia e otimiza√ß√£o complexa.


### Breve Hist√≥ria e Estado Atual da Tecnologia

A ideia de um computador qu√¢ntico foi formalmente proposta na d√©cada de 1980 por Richard Feynman e Yuri Manin, ao observarem que simular sistemas qu√¢nticos usando computadores cl√°ssicos √© extremamente ineficiente, pois a quantidade de recursos necess√°rios cresce exponencialmente com o tamanho do sistema. Eles sugeriram que apenas m√°quinas que tamb√©m obedecessem √†s leis da mec√¢nica qu√¢ntica poderiam realizar tais simula√ß√µes de forma eficiente.

Nos anos 1990, o campo ganhou for√ßa com descobertas marcantes:  
- Algoritmo de *Shor (1994)* ‚Äì criado por *Peter Shor*, mostrou que um computador qu√¢ntico poderia fatorar n√∫meros grandes de forma exponencialmente mais r√°pida do que os melhores algoritmos cl√°ssicos conhecidos, amea√ßando a criptografia RSA.  
- Algoritmo de *Grover (1996)* ‚Äì desenvolvido por *Lov Grover*, ofereceu uma acelera√ß√£o quadr√°tica na busca n√£o estruturada, com impacto potencial em diversas √°reas.

Hoje, a tecnologia vive a chamada era NISQ (*Noisy Intermediate-Scale Quantum*), termo cunhado por *John Preskill* em 2018. Nessa fase:  
- Os processadores possuem dezenas a poucos centenas de *qubits*.  
- Os *qubits* s√£o ruidosos, com tempos de coer√™ncia limitados.  
- Os circuitos s√≥ podem ter profundidade restrita antes que o ru√≠do degrade os resultados.  

Mesmo assim, grandes avan√ßos foram alcan√ßados:  
- Empresas como *IBM, Google, Rigetti, IonQ e Xanadu* oferecem acesso a computadores qu√¢nticos reais via nuvem, permitindo que pesquisadores e desenvolvedores experimentem com algoritmos qu√¢nticos sem possuir o hardware.  
- Em 2019, a *Google* anunciou ter atingido a chamada supremacia qu√¢ntica, realizando uma tarefa espec√≠fica em seu processador *Sycamore* de 53 *qubits* que, segundo a empresa, levaria milhares de anos para um supercomputador cl√°ssico resolver.  
- A *IBM* e outras empresas trabalham na escalabilidade, prevendo processadores com mais de 1.000 *qubits* nos pr√≥ximos anos.

Embora um computador qu√¢ntico universal e tolerante a falhas ainda esteja distante, j√° √© poss√≠vel explorar aplica√ß√µes pr√°ticas em otimiza√ß√£o, simula√ß√£o de materiais e qu√≠mica qu√¢ntica, al√©m de pesquisa fundamental. O campo est√° em r√°pida evolu√ß√£o, com constantes melhorias na fidelidade dos qubits, t√©cnicas de corre√ß√£o de erros e novos modelos de arquitetura.

### Tipos de Computadores Qu√¢nticos

A computa√ß√£o qu√¢ntica pode ser implementada de diferentes maneiras, cada uma explorando fen√¥menos qu√¢nticos espec√≠ficos para armazenar e manipular informa√ß√£o. As principais arquiteturas s√£o:

#### 1. Supercondutores
Os computadores qu√¢nticos supercondutores utilizam circuitos feitos de materiais que apresentam supercondutividade, ou seja, resist√™ncia el√©trica nula, quando resfriados a temperaturas pr√≥ximas do zero absoluto (cerca de 15‚Äì20 *milikelvin*, obtidos com refrigeradores de dilui√ß√£o).  
O qubit √© implementado como um circuito ressonante que pode oscilar entre dois estados de energia, controlados por micro-ondas.  
- Vantagens: Escalabilidade relativamente alta e integra√ß√£o com tecnologias de fabrica√ß√£o j√° consolidadas na ind√∫stria de semicondutores.  
- Desafios: Requerem temperaturas extremamente baixas e possuem tempos de coer√™ncia relativamente curtos.  
- Exemplos: *IBM (IBM Quantum), Google (Sycamore), Rigetti Computing*.

#### 2. √çons Aprisionados
Nessa abordagem, √°tomos carregados (√≠ons) s√£o aprisionados em campos eletromagn√©ticos gerados por armadilhas de *Paul* ou *Penning*. Cada √≠on representa um qubit e seus estados qu√¢nticos s√£o manipulados com pulsos de *laser* altamente precisos. O entrela√ßamento √© obtido via intera√ß√µes vibracionais compartilhadas entre os √≠ons.  
- Vantagens: Tempos de coer√™ncia muito longos e alta fidelidade nas opera√ß√µes.  
- Desafios: Aumentar o n√∫mero de √≠ons em uma mesma armadilha e manter o controle preciso se torna dif√≠cil com a escalabilidade.  
- Exemplos: *IonQ, Honeywell Quantum Solutions* (agora *Quantinuum*).

#### 3. Fot√¥nicos
Nesta arquitetura, f√≥tons (part√≠culas de luz) s√£o usados como qubits, geralmente codificando informa√ß√£o em propriedades como polariza√ß√£o, modo espacial ou tempo de chegada. A manipula√ß√£o √© feita por meio de divisores de feixe, moduladores de fase e detectores fotossens√≠veis.  
- Vantagens: Operam √† temperatura ambiente, com baix√≠ssimo ru√≠do e facilidade de transmiss√£o por fibras √≥pticas (ideal para comunica√ß√£o qu√¢ntica).  
- Desafios: Dificuldade em criar intera√ß√µes fortes entre f√≥tons, o que complica a implementa√ß√£o de portas l√≥gicas universais.  
- Exemplos: Xanadu (fot√¥nica baseada em luz comprimida), PsiQuantum.

#### 4. Spin em Pontos Qu√¢nticos
Essa abordagem utiliza el√©trons confinados em nanodispositivos semicondutores chamados pontos qu√¢nticos. O qubit √© representado pelo *spin* do el√©tron (para cima ou para baixo), manipulado por campos magn√©ticos ou el√©tricos.  
- Vantagens: Compatibilidade com t√©cnicas de fabrica√ß√£o de chips de sil√≠cio e potencial de integra√ß√£o em larga escala.  
- Desafios: Manter o isolamento contra ru√≠do magn√©tico e el√©trico, e alcan√ßar tempos de coer√™ncia suficientemente longos.  
- Exemplos: Pesquisas da Intel e da Universidade de *New South Wales*.

#### 5. Centros de Vac√¢ncia de Nitrog√™nio em Diamante (NV Centers)
Aqui, utiliza-se um defeito na rede cristalina do diamante em que um √°tomo de nitrog√™nio substitui um de carbono e h√° uma lacuna (vac√¢ncia) adjacente. O *spin* do el√©tron associado a esse defeito √© usado como qubit, controlado por micro-ondas e luz laser.  
- Vantagens: Operam em temperatura ambiente e t√™m longos tempos de coer√™ncia, especialmente em diamantes isotopicamente puros.  
- Desafios: Dificuldade em escalar para muitos qubits interconectados e no controle preciso de m√∫ltiplos defeitos.  
- Exemplos: Pesquisa da *Element Six, QuTech*.

---

Cada tecnologia apresenta um equil√≠brio diferente entre fidelidade, tempo de coer√™ncia, velocidade de opera√ß√£o e escalabilidade. Atualmente, n√£o existe consenso sobre qual ser√° a arquitetura dominante no futuro. √â poss√≠vel que diferentes tipos coexistam, cada um otimizando aplica√ß√µes espec√≠ficas.


### Aplica√ß√µes Reais e Promissoras

Mesmo na era *NISQ* (*Noisy Intermediate-Scale Quantum*), na qual os processadores qu√¢nticos possuem limita√ß√µes de escala e est√£o sujeitos a ru√≠dos, a computa√ß√£o qu√¢ntica j√° apresenta potencial para transformar diversas √°reas. Algumas das aplica√ß√µes mais relevantes incluem:

#### 1. Simula√ß√£o Qu√¢ntica
A mec√¢nica qu√¢ntica descreve naturalmente o comportamento de mol√©culas, √°tomos e part√≠culas. Computadores cl√°ssicos t√™m dificuldade em simular sistemas qu√¢nticos complexos devido ao crescimento exponencial do espa√ßo de estados. J√° os computadores qu√¢nticos podem modelar mol√©culas e rea√ß√µes qu√≠micas de forma nativa, permitindo avan√ßos na descoberta de novos medicamentos, catalisadores e materiais com propriedades √∫nicas.

#### 2. Otimiza√ß√£o
Muitos problemas do mundo real, como roteiriza√ß√£o de transporte, aloca√ß√£o de recursos e planejamento de produ√ß√£o, s√£o combinat√≥rios e dif√≠ceis de resolver com efici√™ncia por m√©todos cl√°ssicos. Algoritmos qu√¢nticos, como o *QAOA (Quantum Approximate Optimization Algorithm)*, podem encontrar solu√ß√µes aproximadas com maior rapidez, tornando-se √∫teis para log√≠stica, telecomunica√ß√µes e engenharia.

#### 3. Criptografia
A computa√ß√£o qu√¢ntica tem impacto duplo na seguran√ßa digital:

- Amea√ßa: Algoritmos como o de *Shor* podem fatorar grandes n√∫meros exponencialmente mais r√°pido que os melhores m√©todos cl√°ssicos, comprometendo sistemas como RSA e ECC.

- Defesa: Desenvolve-se a criptografia qu√¢ntica, como a Distribui√ß√£o Qu√¢ntica de Chaves (QKD), que utiliza as leis da f√≠sica qu√¢ntica para garantir seguran√ßa incondicional.

#### 4. Aprendizado de M√°quina Qu√¢ntico (Quantum Machine Learning ‚Äì QML)
Algoritmos qu√¢nticos podem acelerar partes do treinamento e da infer√™ncia de modelos de *machine learning*, explorando a capacidade de representar e manipular grandes vetores de forma mais eficiente. Isso pode beneficiar √°reas como processamento de imagens, an√°lise de dados e reconhecimento de padr√µes.

#### 5. An√°lise Financeira
Mercados financeiros s√£o sistemas complexos e probabil√≠sticos. Computadores qu√¢nticos podem ajudar a modelar risco, prever tend√™ncias de mercado e otimizar carteiras de investimento, possibilitando estrat√©gias mais robustas e r√°pidas de avalia√ß√£o de cen√°rios.


### Limita√ß√µes e Desafios Atuais

Apesar do imenso potencial da computa√ß√£o qu√¢ntica, existem barreiras t√©cnicas e cient√≠ficas que ainda precisam ser superadas para que essa tecnologia alcance seu uso pleno. Entre os principais desafios, destacam-se:

#### 1. Tempo de Coer√™ncia
Os qubits mant√™m seu estado qu√¢ntico apenas por um intervalo de tempo limitado, chamado tempo de coer√™ncia. Passado esse per√≠odo, efeitos como descoer√™ncia e intera√ß√µes com o ambiente fazem com que a informa√ß√£o qu√¢ntica se perca. Essa limita√ß√£o exige que os c√°lculos sejam conclu√≠dos rapidamente ou que t√©cnicas de preserva√ß√£o do estado sejam aplicadas.

#### 2. Escalabilidade
Construir sistemas com milhares ou milh√µes de qubits est√°veis √© um enorme desafio de engenharia. O aumento no n√∫mero de qubits requer um controle preciso de cada unidade e de suas intera√ß√µes, mantendo ao mesmo tempo a integridade dos dados e reduzindo o impacto do ru√≠do.

#### 3. Ru√≠do e Erros
Opera√ß√µes qu√¢nticas ainda s√£o imprecisas devido a erros de porta, erros de leitura e *u√≠dos ambientais. Esses problemas afetam a fidelidade dos resultados, tornando essencial o uso de corre√ß√£o de erros qu√¢nticos que, por sua vez, aumenta a demanda de qubits f√≠sicos para representar um √∫nico qubit l√≥gico.

#### 4. Infraestrutura
A maior parte das arquiteturas qu√¢nticas exige condi√ß√µes extremas de opera√ß√£o, como resfriamento criog√™nico pr√≥ximo ao zero absoluto para qubits supercondutores, ou sistemas complexos de lasers e v√°cuo para √≠ons aprisionados. Essa infraestrutura √© cara, ocupa muito espa√ßo e demanda manuten√ß√£o altamente especializada.

#### 5. Algoritmos Limitados
Embora existam algoritmos qu√¢nticos promissores, como os de *Shor* e *Grover*, ainda s√£o poucos os m√©todos que demonstram vantagem qu√¢ntica pr√°tica sobre algoritmos cl√°ssicos em problemas do mundo real. Pesquisas continuam na busca por novos algoritmos capazes de explorar plenamente o potencial dos processadores qu√¢nticos.


## Conceitos Fundamentais

### Qubits

O qubit (*quantum bit*) √© a unidade fundamental de informa√ß√£o na computa√ß√£o qu√¢ntica, an√°logo ao bit da computa√ß√£o cl√°ssica.  
Enquanto um bit cl√°ssico s√≥ pode assumir dois valores poss√≠veis, `0` ou `1`, um qubit pode estar em uma superposi√ß√£o desses estados, representando simultaneamente `0` e `1` com determinadas probabilidades.

Matematicamente, um qubit √© descrito como um vetor no espa√ßo de Hilbert bidimensional:

$$
|\psi\rangle = \alpha |0\rangle + \beta |1\rangle
$$

Onde:

- $\alpha$ e $\beta$ s√£o n√∫meros complexos conhecidos como amplitudes de probabilidade.

- $|0\rangle$ e $|1\rangle$ s√£o os estados base (an√°logos a 0 e 1 cl√°ssicos).

- A normaliza√ß√£o exige que:

$$
|\alpha|^2 + |\beta|^2 = 1
$$

O ato de medir um qubit faz com que ele colapse para `|0‚ü©` com probabilidade $|\alpha|^2$ ou para `|1‚ü©` com probabilidade $|\beta|^2$.

#### Representa√ß√£o no Esfera de Bloch
Todo qubit puro pode ser representado na Esfera de *Bloch* por dois √¢ngulos $(\theta, \phi)$:

$$
|\psi\rangle = \cos\left(\frac{\theta}{2}\right)|0\rangle + e^{i\phi} \sin\left(\frac{\theta}{2}\right)|1\rangle
$$

- $\theta$ controla a propor√ß√£o entre os estados `|0‚ü©` e `|1‚ü©`.

- $\phi$ determina a fase relativa entre eles.

- Essa representa√ß√£o √© √∫til para visualizar opera√ß√µes qu√¢nticas como rota√ß√µes e portas l√≥gicas.

#### Natureza F√≠sica dos Qubits
Qubits n√£o s√£o apenas abstra√ß√µes matem√°ticas, eles s√£o implementados fisicamente de v√°rias formas:
- F√≥tons, utilizando polariza√ß√£o ou caminho √≥ptico.
- El√©trons, aproveitando o spin ou carga.
- Estados de corrente em circuitos supercondutores.
- √çons aprisionados, manipulados por lasers.

Cada tecnologia apresenta vantagens e limita√ß√µes em termos de tempo de coer√™ncia, facilidade de manipula√ß√£o e taxa de erro.

Em resumo, enquanto os bits cl√°ssicos representam informa√ß√£o de forma discreta e est√°tica, os qubits permitem superposi√ß√£o e entrela√ßamento, proporcionando um espa√ßo de estados exponencialmente maior e habilitando algoritmos com vantagens significativas sobre os m√©todos cl√°ssicos.

### Portas Qu√¢nticas

As portas qu√¢nticas s√£o os blocos fundamentais que permitem manipular o estado dos qubits durante o processamento qu√¢ntico. Elas s√£o an√°logas √†s portas l√≥gicas na computa√ß√£o cl√°ssica (como AND, OR, NOT), mas operam em estados qu√¢nticos que podem estar em superposi√ß√£o e entrela√ßamento.

Diferentemente das portas cl√°ssicas, as portas qu√¢nticas s√£o representadas por matrizes unit√°rias que atuam sobre o vetor de estado do(s) qubit(s). Essa opera√ß√£o √© revers√≠vel, preservando a normaliza√ß√£o do estado.

---

### Propriedades Importantes das Portas Qu√¢nticas

- Unitariedade: Toda porta qu√¢ntica √© representada por uma matriz unit√°ria \(U\), o que garante reversibilidade e preserva√ß√£o da normaliza√ß√£o:  
  \[
  U^\dagger U = U U^\dagger = I
  \]
- Reversibilidade: Diferente das portas cl√°ssicas que podem ser irrevers√≠veis, as opera√ß√µes qu√¢nticas podem ser invertidas.
- Composi√ß√£o: Portas qu√¢nticas podem ser compostas para formar circuitos complexos que realizam algoritmos completos.

---

#### Portas de Um Qubit

##### 1. Porta Hadamard (H)

- **Fun√ß√£o:** Cria superposi√ß√£o ao transformar os estados base \( |0\rangle \) e \( |1\rangle \) em combina√ß√µes iguais.  
- **Opera√ß√£o:** 
\[
H|0\rangle = \frac{|0\rangle + |1\rangle}{\sqrt{2}}, \quad H|1\rangle = \frac{|0\rangle - |1\rangle}{\sqrt{2}}
\]
- **Matriz:**
\[
H = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 1 \\
1 & -1
\end{bmatrix}
\]
- **Uso comum:** Preparar qubits para criar estados em superposi√ß√£o.

---

##### 2. Porta Pauli-X (NOT qu√¢ntico)

- **Fun√ß√£o:** Equivale √† porta NOT cl√°ssica, invertendo os estados \(|0\rangle \leftrightarrow |1\rangle\).  
- **Opera√ß√£o:**  
\[
X|0\rangle = |1\rangle, \quad X|1\rangle = |0\rangle
\]
- **Matriz:**
\[
X =
\begin{bmatrix}
0 & 1 \\
1 & 0
\end{bmatrix}
\]
- **Uso comum:** Flips simples de estado qu√¢ntico.

---

##### 3. Porta Pauli-Y

- **Fun√ß√£o:** Realiza uma rota√ß√£o combinada com invers√£o e mudan√ßa de fase.  
- **Matriz:**
\[
Y =
\begin{bmatrix}
0 & -i \\
i & 0
\end{bmatrix}
\]

---

##### 4. Porta Pauli-Z

- **Fun√ß√£o:** Aplica uma mudan√ßa de fase, deixando \(|0\rangle\) inalterado e invertendo o sinal de \(|1\rangle\).  
- **Opera√ß√£o:** 
\[
Z|0\rangle = |0\rangle, \quad Z|1\rangle = -|1\rangle
\]
- **Matriz:**
\[
Z =
\begin{bmatrix}
1 & 0 \\
0 & -1
\end{bmatrix}
\]
- **Uso comum:** Portas de fase e corre√ß√µes.

---

##### 5. Porta de Fase (S e T)

- **Fun√ß√£o:** Aplicam mudan√ßas graduais de fase ao estado \(|1\rangle\).  
- **Matriz S:**
\[
S =
\begin{bmatrix}
1 & 0 \\
0 & i
\end{bmatrix}
\]
- **Matriz T:**
\[
T =
\begin{bmatrix}
1 & 0 \\
0 & e^{i\pi/4}
\end{bmatrix}
\]
- **Uso comum:** Constru√ß√£o de circuitos universais e corre√ß√£o de erros.

---

##### 6. Porta de Rota√ß√£o \(R_x, R_y, R_z\)

- **Fun√ß√£o:** Rotaciona o vetor de estado do qubit ao redor dos eixos X, Y ou Z da esfera de Bloch por um √¢ngulo \(\theta\).  
- **Exemplo \(R_z(\theta)\):**  
\[
R_z(\theta) = 
\begin{bmatrix}
e^{-i\theta/2} & 0 \\
0 & e^{i\theta/2}
\end{bmatrix}
\]
- **Uso comum:** Ajustes finos de fase e manipula√ß√µes de estado.

---

#### Portas de Dois ou Mais Qubits

##### 1. Porta CNOT (Controlled-NOT)

- **Fun√ß√£o:** Porta fundamental para criar entrela√ßamento; inverte o estado do qubit alvo se o qubit controle estiver em \(|1\rangle\).  
- **Opera√ß√£o:**
\[
|c, t\rangle \rightarrow |c, t \oplus c\rangle
\]
onde \(c\) √© o qubit controle e \(t\) o qubit alvo.  
- **Matriz (base computacional \( \{|00\rangle, |01\rangle, |10\rangle, |11\rangle\} \)):**
\[
\text{CNOT} = 
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0
\end{bmatrix}
\]
- **Uso comum:** Criar estados entrela√ßados e construir circuitos universais.

---

##### 2. Porta Toffoli (CCNOT)

- **Fun√ß√£o:** Porta de controle duplo; inverte o alvo somente se ambos os controles estiverem em \(|1\rangle\).  
- **Uso comum:** Constru√ß√£o de portas universais revers√≠veis.

---

##### 3. Porta SWAP

- **Fun√ß√£o:** Troca o estado de dois qubits.  
- **Uso comum:** Permuta√ß√£o de qubits em hardware com restri√ß√µes de conectividade.


### Portas Universais

Um conjunto de portas √© dito universal se qualquer opera√ß√£o qu√¢ntica (unidade) puder ser aproximada arbitrariamente bem por uma sequ√™ncia dessas portas. Exemplos incluem:  
- Portas de um qubit: \(H, T, S, R_x, R_y, R_z\)  
- Portas de dois qubits: CNOT

Com essas portas, √© poss√≠vel construir qualquer circuito qu√¢ntico.


## Simulador Qiskit (IBM)

O Qiskit √© um framework open-source desenvolvido pela IBM para programar computadores qu√¢nticos e simuladores qu√¢nticos. Ele permite criar, manipular e executar circuitos qu√¢nticos, seja em hardware real ou em simuladores cl√°ssicos que reproduzem o comportamento qu√¢ntico.

Nesta se√ß√£o, apresentaremos exemplos simples de uso do Qiskit para demonstrar a constru√ß√£o de circuitos b√°sicos, aplica√ß√£o de portas qu√¢nticas e visualiza√ß√£o dos circuitos.

---

### Exemplo 1: Aplicando uma porta Hadamard

A porta Hadamard cria uma superposi√ß√£o, transformando o estado base \(|0\rangle\) em \(\frac{|0\rangle + |1\rangle}{\sqrt{2}}\).

```python
from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator

# Circuito
qc = QuantumCircuit(1, 1)
qc.h(0)
qc.measure(0, 0)

# Simulador
simulator = AerSimulator()

# Rodar o circuito
job = simulator.run(qc, shots=1024)
result = job.result()
counts = result.get_counts(qc)

print("Resultado da medi√ß√£o:", counts)
print(qc.draw())

```

### Exemplo 2: Pauli-X seguido de Hadamard
```python
from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator

# Criando o circuito
qc2 = QuantumCircuit(1, 1)
qc2.x(0)    # Porta Pauli-X (NOT qu√¢ntico)
qc2.h(0)    # Porta Hadamard
qc2.measure(0, 0)

# Criando o simulador
simulator = AerSimulator()

# Executando no simulador
job2 = simulator.run(qc2, shots=1024)
result2 = job2.result()
counts2 = result2.get_counts()

print("Resultado da medi√ß√£o:", counts2)
print(qc2.draw())

```

### Exemplo 3: Circuito com CNOT
```python
from qiskit import QuantumCircuit

# Criar circuito com 2 qubits e 2 bits cl√°ssicos
qc3 = QuantumCircuit(2, 2)
qc3.h(0)      # Hadamard no qubit 0
qc3.cx(0, 1)  # CNOT: qubit 0 controla qubit 1
qc3.measure([0, 1], [0, 1])

# Desenhar o circuito colorido usando matplotlib
qc3.draw(output='mpl')

```

## Medi√ß√£o e Colapso

Na computa√ß√£o qu√¢ntica, a medi√ß√£o √© o processo pelo qual extra√≠mos informa√ß√£o de um qubit. Diferente da computa√ß√£o cl√°ssica, onde o estado √© sempre definido como 0 ou 1, o qubit pode estar em uma superposi√ß√£o desses estados, representado por:

\[
|\psi\rangle = \alpha|0\rangle + \beta|1\rangle
\]

Quando realizamos uma medi√ß√£o no qubit, o estado colapsa para um dos estados base cl√°ssicos, \( |0\rangle \) ou \( |1\rangle \), com probabilidades determinadas pelas amplitudes:

- Probabilidade de medir \( |0\rangle \): \( |\alpha|^2 \)
- Probabilidade de medir \( |1\rangle \): \( |\beta|^2 \)

Este fen√¥meno √© conhecido como colapso da fun√ß√£o de onda e √© fundamental para a computa√ß√£o qu√¢ntica, pois define a transi√ß√£o do mundo qu√¢ntico probabil√≠stico para o mundo cl√°ssico determin√≠stico.

---

### Implica√ß√µes da Medi√ß√£o

- Colapso irrevers√≠vel: Ap√≥s a medi√ß√£o, o estado do qubit deixa de estar em superposi√ß√£o e fica fixo no estado medido.
- Destrui√ß√£o da superposi√ß√£o: A medi√ß√£o destr√≥i a informa√ß√£o contida na superposi√ß√£o, portanto, medir cedo demais em um circuito pode impedir o funcionamento correto de algoritmos qu√¢nticos.
- Medidas em m√∫ltiplos qubits: Quando qubits est√£o entrela√ßados, medir um deles instantaneamente define o estado dos outros, independente da dist√¢ncia, refletindo o fen√¥meno do entrela√ßamento.

---

### Medi√ß√£o no Qiskit

No Qiskit, a medi√ß√£o √© realizada conectando os qubits aos bits cl√°ssicos correspondentes para armazenar o resultado da medi√ß√£o. Por exemplo:

```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(1, 1)
qc.h(0)           # Cria superposi√ß√£o
qc.measure(0, 0)  # Mede o qubit 0 e armazena no bit cl√°ssico 0
print(qc.draw())
```

Ap√≥s a medi√ß√£o, ao executar o circuito no simulador, obtemos um resultado cl√°ssico (0 ou 1) com probabilidades aproximadas conforme a superposi√ß√£o criada.


## Exemplos de Aplica√ß√µes

### Teleporte Qu√¢ntico

O teleporte qu√¢ntico √© um dos protocolos mais incr√≠veis da computa√ß√£o qu√¢ntica. Ele permite transferir o estado qu√¢ntico de uma part√≠cula (um qubit) de um local para outro, sem que o qubit original seja enviado fisicamente. √â como se a informa√ß√£o qu√¢ntica "saltasse" de um ponto para o outro, uma ideia que desafia nossa intui√ß√£o cl√°ssica.

O protocolo usa duas ferramentas fundamentais da mec√¢nica qu√¢ntica:

- Entrela√ßamento (entanglement): dois qubits s√£o preparados de forma que seus estados fiquem interligados, mesmo que estejam separados no espa√ßo.  
- Medidas e opera√ß√µes condicionais: ao medir um dos qubits entrela√ßados e usar o resultado para manipular o outro qubit, conseguimos "reconstruir" o estado original.

---

#### Como funciona o protocolo de teleporte?

Suponha que Alice quer enviar para Bob um qubit desconhecido, ou seja, o estado qu√¢ntico de um qubit que ela n√£o sabe exatamente como √©, mas quer transferir para ele.

1. Alice e Bob compartilham um par de qubits entrela√ßados. Alice fica com um deles, Bob com o outro.  
2. Alice faz uma opera√ß√£o conjunta (chamada de medida Bell) entre o qubit que deseja enviar e o qubit dela do par entrela√ßado. Essa opera√ß√£o resulta em dois bits cl√°ssicos, que Alice envia para Bob por um canal cl√°ssico.  
3. Com esses dois bits, Bob aplica portas qu√¢nticas espec√≠ficas no seu qubit (que estava entrela√ßado com o de Alice), e assim recupera exatamente o estado original do qubit que Alice queria enviar.

> Importante: depois do teleporte, o qubit original de Alice deixa de existir, preservando o princ√≠pio da n√£o clonagem.

---

#### C√≥digo
```python
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram
import numpy as np
from IPython.display import display
import warnings
warnings.filterwarnings("ignore", category=UserWarning)

# --- Cria√ß√£o dos registradores qu√¢nticos e cl√°ssicos ---
alice = QuantumRegister(2, 'alice')
bob = QuantumRegister(1, 'bob')
cr_alice = ClassicalRegister(2, 'c_alice')
cr_bob = ClassicalRegister(1, 'c_bob')

qc = QuantumCircuit(alice, bob, cr_alice, cr_bob)

# --- Inicializa√ß√£o do estado a ser teleportado ---
qc.ry(np.pi/4, alice[0])
qc.barrier()

# --- Prepara√ß√£o do par entrela√ßado (Bell state) ---
qc.h(alice[1])
qc.cx(alice[1], bob[0])
qc.barrier()

# --- Medidas de Alice ---
qc.cx(alice[0], alice[1])
qc.h(alice[0])
qc.barrier()
qc.measure(alice, cr_alice)
qc.barrier()

# --- Corre√ß√µes condicionais no qubit de Bob ---
qc.cx(alice[1], bob[0])
qc.cz(alice[0], bob[0])
qc.barrier()
qc.measure(bob, cr_bob)

# --- Desenho do circuito ---
display(qc.draw(output='mpl'))

# --- Simula√ß√£o QASM para contagens ---
simulator = AerSimulator()
compiled = transpile(qc, simulator)
shots = 10000
result = simulator.run(compiled, shots=shots).result()
counts = result.get_counts()
print("Contagem dos resultados (medidas de Alice e Bob):")
print(counts)

# --- Histograma das contagens ---
plot_histogram(counts)


```

---

### Adder Qu√¢ntico com QFT

O Adder Qu√¢ntico utiliza a Transformada Qu√¢ntica de Fourier (QFT) para realizar a soma de dois n√∫meros bin√°rios representados por qubits.

---

#### Como funciona?

- Cada n√∫mero a ser somado √© representado em um registrador de qubits.  
- Aplica-se a QFT para transformar o estado dos qubits para o dom√≠nio da frequ√™ncia, onde a soma pode ser feita por opera√ß√µes de fase.  
- Ap√≥s a adi√ß√£o no dom√≠nio da frequ√™ncia, aplica-se a Transformada Qu√¢ntica de Fourier Inversa (IQFT) para retornar ao dom√≠nio computacional, obtendo o resultado da soma.  
- Por fim, os qubits s√£o medidos para revelar o valor da soma.

---

#### Benef√≠cios

- A opera√ß√£o √© feita em paralelo e pode ser mais eficiente em circuitos qu√¢nticos.  
- Demonstra um uso pr√°tico da QFT, fundamental em muitos algoritmos qu√¢nticos.

---

#### C√≥digo

```python
import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit.circuit.library import QFT, DraperQFTAdder
from qiskit.visualization import plot_histogram
from qiskit_aer import AerSimulator

# --- Exemplo 1: Soma usando DraperQFTAdder ---

a = 8
b = 5
n = len(format(a + b, '0b'))  # n√∫mero de qubits necess√°rios para soma

na = len(format(a, '0b'))
nb = len(format(b, '0' + str(n) + 'b'))

qa = QuantumRegister(na, 'a')
qb = QuantumRegister(nb, 'b')
cr = ClassicalRegister(nb, 'c')
qc = QuantumCircuit(qa, qb, cr)

# Inicializar registradores com os n√∫meros a e b (em bin√°rio, invertido)
a_bin = format(a, '0b')[::-1]
b_bin = format(b, '0b')[::-1]

for i, bit in enumerate(a_bin):
    if bit == '1':
        qc.x(qa[i])
for i, bit in enumerate(b_bin):
    if bit == '1':
        qc.x(qb[i])

# Adder via Draper QFT
qc.append(DraperQFTAdder(n), qc.qubits)

# Medir resultado
qc.measure(qb, cr)

# Executar no simulador
simulator = AerSimulator()
compiled = transpile(qc, simulator)
result = simulator.run(compiled, shots=10000).result().get_counts()
soma_bin = max(result, key=result.get)  # pega o resultado com maior frequ√™ncia

print(f"O resultado da soma √© {soma_bin} (bin√°rio) = {int(soma_bin, 2)} (decimal)")

plot_histogram(result, figsize=(4,3))


# --- Exemplo 2: QFT simples ---

n = 4
qr = QuantumRegister(n, 'q')
qc = QuantumCircuit(qr)

for i in range(n-1, -1, -1):
    qc.h(i)
    for j in range(i-1, -1, -1):
        qc.cp(np.pi/(2**(i-j)), i, j)
    qc.barrier()

# Swap qubits para inverter ordem
for i in range(n//2):
    qc.swap(i, n - i - 1)

qc.draw('mpl', scale=0.9, style='iqx')


# --- Exemplo 3: Circuito com QFT seguido de IQFT ---

def qft(n):
    qc = QuantumCircuit(n)
    for i in range(n-1, -1, -1):
        qc.h(i)
        for j in range(i-1, -1, -1):
            qc.cp(np.pi/(2**(i-j)), i, j)
    return qc.to_gate(label='QFT')

def iqft(n):
    qc = QuantumCircuit(n)
    qc.append(qft(n), range(n))
    qc = qc.inverse()
    return qc.to_gate(label='IQFT')

n = 3
qc = QuantumCircuit(n)
qc.append(qft(n), range(n))
qc.append(iqft(n), range(n))
qc.draw('mpl', style='iqx', scale=0.9)


# --- Exemplo 4: Soma via QFT personalizada (mais detalhada) ---

ints = [3, 5]
qubits_qft = len(format(sum(ints), '0b'))
qubits_x = len(format(max(ints), '0b'))

qr_data_int = QuantumRegister(qubits_x, "data_x")
qr_data_qft = QuantumRegister(qubits_qft, "qft")
cr1 = ClassicalRegister(qubits_qft, 'c_qft')

qc = QuantumCircuit(qr_data_int, qr_data_qft, cr1)
qc.append(qft(qubits_qft), qr_data_qft)

for x in ints:
    k = format(x, '0b')[::-1]
    for i, bit in enumerate(k):
        if bit == '1':
            qc.x(qr_data_int[i])

    for j in range(len(qr_data_int)):
        for i in range(j, len(qr_data_qft)):
            qc.cp(2*np.pi / 2**(i + 1 - j), qr_data_int[j], qr_data_qft[i])
        qc.barrier()

    for i, bit in enumerate(k):
        if bit == '1':
            qc.x(qr_data_int[i])
    qc.barrier()

qc.append(iqft(qubits_qft), qr_data_qft)
qc.measure(qr_data_qft, cr1)

compiled = transpile(qc, simulator)
result = simulator.run(compiled, shots=10000).result().get_counts()

print(f"\nSoma dos n√∫meros {ints} via QFT √© aproximadamente:")
plot_histogram(result, figsize=(8, 4))

```

---

### Quantum Phase Estimation (QPE)

Quantum Phase Estimation (QPE) √© um dos algoritmos mais importantes da computa√ß√£o qu√¢ntica, usado para estimar o valor do autovalor (fase) de um operador unit√°rio.

---

#### O que √© QPE?

- O algoritmo QPE estima a fase \(\theta\) em um autovetor \(|u\rangle\) de um operador unit√°rio \(U\), tal que:
  
  \[
  U|u\rangle = e^{2\pi i \theta} |u\rangle
  \]

- A fase \(\theta\) √© um n√∫mero real entre 0 e 1, e a estimativa dessa fase √© crucial para algoritmos como o de Shor e simula√ß√µes qu√¢nticas.

---

#### Como funciona?

- Usa-se um registrador de qubits para armazenar a estimativa da fase.  
- Inicializa-se os qubits com portas Hadamard para criar superposi√ß√£o.  
- Aplica-se o operador controlado \(U^{2^j}\) para diferentes pot√™ncias.  
- Aplica-se a Transformada Qu√¢ntica de Fourier Inversa (IQFT) para extrair a informa√ß√£o da fase.  
- Mede-se o registrador para obter a estimativa bin√°ria da fase.

---

#### C√≥digo

```python
import numpy as np
from scipy.linalg import expm
from qiskit import QuantumCircuit
from qiskit.circuit.library import UnitaryGate
from qiskit_aer import AerSimulator
from qiskit import transpile
from qiskit.visualization import plot_histogram
from IPython.display import display

# N√∫mero de qubits para o registrador de fase (controle)
n = 10

# Matriz identidade 2x2
Id = np.eye(2)

# Definindo o √¢ngulo theta da fase que queremos estimar
theta = 0.15

# Construindo a porta unit√°ria U = exp(2*pi*i*theta*I)
U_matrix = expm(2 * 1j * np.pi * theta * Id)
U_gate = UnitaryGate(U_matrix, label='U')

# Criando a porta controlada-U
controlled_U = U_gate.control(1)  # substitui add_control

print('Expected phase (theta):', theta)

# Fun√ß√£o para construir o circuito QPE
def qpe(n, controlled_u):
    # Registradores: n qubits de controle + 1 alvo
    qc = QuantumCircuit(n + 1, n)
    
    # Aplicar Hadamard a todos os qubits de controle
    for i in range(n):
        qc.h(i)
    # Preparar o qubit alvo no estado |1>
    qc.x(n)
    
    # Aplicar os controlled-U^(2^i) nos qubits de controle
    for i in range(n):
        for _ in range(2**i):
            qc.append(controlled_u, [i, n])
    
    # Aplicar inversa da QFT nos qubits de controle
    qft_circ = qft(QuantumCircuit(n), n)
    invqft_circ = qft_circ.inverse()
    qc.append(invqft_circ, qc.qubits[:n])
    
    # Medir os qubits de controle
    qc.measure(range(n), range(n))
    
    return qc

# Fun√ß√£o para construir o circuito da QFT
def qft(qc, n):
    for i in range(n):
        qc.h(n - i - 1)
        for j in range(n - i - 1):
            qc.cp(np.pi / (2 ** (n - i - j - 1)), n - i - 1, j)
        qc.barrier()
    # Swap para inverter ordem dos qubits
    for i in range(n // 2):
        qc.swap(i, n - i - 1)
    return qc

# Construindo circuito QPE
qc = qpe(n, controlled_U)

# Mostrar circuito
display(qc.draw('mpl'))

# Executar em simulador
simulator = AerSimulator()
compiled = transpile(qc, simulator)
shots = 10000
result = simulator.run(compiled, shots=shots).result().get_counts()

# Ordenar resultados por probabilidade
states = sorted([[result[i] / shots, i] for i in result], reverse=True)
res = [int(i[1], 2) for i in states]

# An√°lise do resultado
if len(res) > 1 and states[1][0] > 0.1:
    print('The phase is between:', res[0] / 2 ** n, res[1] / 2 ** n)
else:
    print('The phase is:', res[0] / 2 ** n)

print('Measured integers:', res[:2])

# Plotar histograma dos resultados
plot_histogram(result, figsize=(12, 6))

```

---

### Algoritmo de Grover

O algoritmo de Grover √© um algoritmo qu√¢ntico usado para buscar estados espec√≠ficos em uma superposi√ß√£o com complexidade quadr√°tica mais r√°pida que a busca cl√°ssica. Ele √© √∫til quando queremos encontrar alvos em grandes bases de dados n√£o estruturadas.

---

### O que √© Grover?

Dado um conjunto de N = 2^n estados poss√≠veis, e um subconjunto de M estados alvo, o algoritmo de *Grover* aumenta a probabilidade de medir os estados desejados.

Enquanto uma busca cl√°ssica precisa de O(N) tentativas, *Grover* consegue localizar os alvos em O(sqrt(N/M)) itera√ß√µes.

---

### Como funciona?

1. Inicializa√ß√£o: todos os qubits s√£o colocados em superposi√ß√£o usando portas Hadamard.  
2. Or√°culo: identifica os estados alvo e inverte a fase deles.  
3. Difusor (invers√£o sobre a m√©dia): amplifica a probabilidade dos estados alvo.  
4. Itera√ß√µes de *Grover*: repete o or√°culo e o difusor um n√∫mero ideal de vezes:
itera√ß√µes ‚âà (œÄ / 4) * sqrt(N / M)
5. Medi√ß√£o: mede os qubits, aumentando significativamente a chance de encontrar os estados desejados.

---

#### C√≥digo

```python
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram
import matplotlib.pyplot as plt
import time
from math import floor, pi, sqrt

# CONFIGURA√á√ïES
n = 10  # n√∫mero de qubits
targets = ['01', '10']  # estados desejados
shots = 1024

def execute_quantum_circuit(circuit):
    start_transpile = time.perf_counter()
    compiled_circuit = transpile(circuit, simulator)
    end_transpile = time.perf_counter()

    start_execute = time.perf_counter()
    sim_result = simulator.run(compiled_circuit, shots=1024).result()
    end_execute = time.perf_counter()

    counts = sim_result.get_counts()
    transpile_time = end_transpile - start_transpile
    execute_time = end_execute - start_execute
    total_time = end_execute - start_transpile
    return counts, transpile_time, execute_time, total_time


# Fun√ß√£o: aplica um or√°culo que marca v√°rios estados (inverte fase de cada alvo)
def apply_oracle(qc, targets):
    for target in targets:
        for i, bit in enumerate(reversed(target)):
            if bit == '0':
                qc.x(i)
        qc.h(n - 1)
        if n == 2:
            qc.cz(0, 1)
        else:
            qc.mcx(list(range(n - 1)), n - 1)
        qc.h(n - 1)
        for i, bit in enumerate(reversed(target)):
            if bit == '0':
                qc.x(i)

# Fun√ß√£o: aplica difusor de Grover (invers√£o sobre a m√©dia)
def apply_diffuser(qc):
    qc.h(range(n))
    qc.x(range(n))
    qc.h(n - 1)
    if n == 2:
        qc.cx(0, 1)
    else:
        qc.mcx(list(range(n - 1)), n - 1)
    qc.h(n - 1)
    qc.x(range(n))
    qc.h(range(n))

# N√∫mero ideal de itera√ß√µes
N = 2 ** n
M = len(targets)
iterations = floor((pi / 4) * sqrt(N / M))

# Inicializa√ß√£o
simulator = AerSimulator()
qc = QuantumCircuit(n, n)
qc.h(range(n))  # Superposi√ß√£o inicial

# Itera√ß√µes de Grover
for _ in range(iterations):
    apply_oracle(qc, targets)
    apply_diffuser(qc)

# Medi√ß√£o
qc.measure(range(n), range(n))

warmup_circuit = QuantumCircuit(1, 1)
warmup_circuit.h(0)
warmup_circuit.measure(0, 0)
_ = execute_quantum_circuit(warmup_circuit)
# Transpila√ß√£o e execu√ß√£o
start_transpile = time.perf_counter()
transpiled = transpile(qc, backend=simulator, optimization_level=3)
end_transpile = time.perf_counter()
transpile_time = end_transpile - start_transpile

start_exec = time.perf_counter()
result = simulator.run(transpiled, shots=shots).result()
end_exec = time.perf_counter()
exec_time = end_exec - start_exec

# Resultados
counts = result.get_counts()
print("üéØ Estados alvos:", targets)
print("üîç Resultado da busca:", counts)
print(f"‚è±Ô∏è Tempo de transpilar: {transpile_time:.6f} segundos")
print(f"‚è±Ô∏è Tempo de execu√ß√£o:  {exec_time:.6f} segundos")

qc.draw(output='mpl')
```

---

### Deutsch-Jozsa
O algoritmo de *Deutsch-Jozsa* √© um dos primeiros algoritmos qu√¢nticos que demonstra vantagem sobre algoritmos cl√°ssicos. Ele decide, com uma √∫nica execu√ß√£o, se uma fun√ß√£o booleana √© constante ou balanceada.


---

### O que √© Deutsch-Jozsa?

- Dada uma fun√ß√£o \(f: \{0,1\}^n \rightarrow \{0,1\}\), a fun√ß√£o √©:
  - Constante: retorna o mesmo valor para todas as entradas.
  - Balanceada: retorna 0 para metade das entradas e 1 para a outra metade.
- Classicamente, precisamos de at√© \(2^{n-1} + 1\) avalia√ß√µes para ter certeza.
- Com Deutsch-Jozsa, conseguimos determinar com uma √∫nica execu√ß√£o qu√¢ntica.

---

### Como funciona?

1. Inicializa√ß√£o:  
   - Preparamos \(n\) qubits de entrada no estado \(|0\rangle\) e 1 qubit auxiliar em \(|1\rangle\).  
   - Aplicamos portas Hadamard nos qubits de entrada para criar superposi√ß√£o.

2. Or√°culo:  
   - Marca os estados conforme a fun√ß√£o \(f\).  
   - Para fun√ß√µes balanceadas, aplica CNOTs do qubit de entrada para o auxiliar.

3. Hadamard novamente:  
   - Aplica portas Hadamard nos qubits de entrada para interfer√™ncia qu√¢ntica.

4. Medi√ß√£o:  
   - Medimos os qubits de entrada.  
   - Se todos forem 0 ‚Üí fun√ß√£o constante, sen√£o ‚Üí fun√ß√£o balanceada.

---

#### C√≥digo

```python
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
import time

# Fun√ß√£o de aquecimento para evitar overhead da primeira transpila√ß√£o/execu√ß√£o
def warmup(simulator):
    warmup_circuit = QuantumCircuit(1, 1)
    warmup_circuit.h(0)
    warmup_circuit.measure(0, 0)
    dummy_compiled = transpile(warmup_circuit, simulator)
    _ = simulator.run(dummy_compiled, shots=1).result()

# Fun√ß√£o do or√°culo de Deutsch-Jozsa (fun√ß√£o balanceada)
def deutsch_jozsa_oracle(qc, n):
    # Aplica CNOTs do qubit i para o auxiliar (√∫ltimo qubit)
    # para v√°rios qubits de entrada, deixando a fun√ß√£o balanceada e mais complexa.
    for i in range(n-1):
        qc.cx(i, n-1)
    return qc

# N√∫mero de qubits
n = 10  
qc = QuantumCircuit(n, n-1)

# Prepara√ß√£o dos qubits
qc.x(n-1)
qc.h(range(n-1))

# Aplicando o or√°culo
qc = deutsch_jozsa_oracle(qc, n)

# Hadamard novamente nos qubits de entrada
qc.h(range(n-1))

# Medi√ß√£o dos qubits de entrada
qc.measure(range(n-1), range(n-1))

# Inicializando o simulador
simulator = AerSimulator()

# Warmup para evitar overhead da primeira execu√ß√£o
warmup(simulator)

# Medi√ß√£o do tempo de transpilar com alta precis√£o
start_transpile = time.perf_counter()
compiled_circuit = transpile(qc, simulator, optimization_level=3)
end_transpile = time.perf_counter()

# Medi√ß√£o do tempo de execu√ß√£o com alta precis√£o
start_execute = time.perf_counter()
result = simulator.run(compiled_circuit, shots=1024).result()
end_execute = time.perf_counter()

# Resultados
counts = result.get_counts()
print("Resultado do Deutsch-Jozsa:", counts)
print(f"Tempo de transpilar: {end_transpile - start_transpile:.6f} segundos")
print(f"Tempo de execu√ß√£o: {end_execute - start_execute:.6f} segundos")
print(f"Tempo total de execu√ß√£o: {end_execute - start_transpile:.6f} segundos")

qc.draw(output='mpl')
```

---

### C√≥digo de Shor (Shor Code)

O c√≥digo de Shor √© um c√≥digo de corre√ß√£o de erros qu√¢nticos que protege um qubit contra *bit-flip* e *phase-flip* usando 9 *qubits* f√≠sicos para codificar 1 *qubit l√≥gico*.

---

### O que √© o c√≥digo de Shor?

- Codifica 1 *qubit* l√≥gico em 9 *qubits* f√≠sicos.  
- Capaz de corrigir qualquer erro de *bit-flip* ou *phase-flip* em um √∫nico qubit.  
- Combina repeti√ß√£o de tr√™s *qubits* para *bit-flip* e codifica√ß√£o de tr√™s *qubits* para *phase-flip*.  

---

### Como funciona?

1. Codifica√ß√£o:  
   - Qubit l√≥gico √© expandido para 9 *qubits* usando portas CNOT e Hadamard.  
   - Primeiro grupo de tr√™s qubits protege contra phase-flip.  
   - Cada qubit do grupo √© expandido para proteger contra bit-flip.

2. Simula√ß√£o de erro:  
   - Pode-se simular um erro, por exemplo, aplicando X (bit-flip) em um *qubits*.

3. Decodifica√ß√£o:  
   - Aplica as portas inversas da codifica√ß√£o para detectar e corrigir o erro.

4. Medi√ß√£o:  
   - Mede os 9 *qubits* para verificar a corre√ß√£o e recuperar o estado l√≥gico.

---

#### C√≥digo

```python
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
from time import perf_counter as time_perf

def execute_quantum_circuit(circuit, simulator):
    # Dummy para aquecer
    warmup = QuantumCircuit(1, 1)
    warmup.h(0)
    warmup.measure(0, 0)
    compiled_warmup = transpile(warmup, simulator)
    simulator.run(compiled_warmup, shots=1).result()

    # Transpila√ß√£o
    start_transpile = time_perf()
    compiled = transpile(circuit, simulator)
    end_transpile = time_perf()

    # Execu√ß√£o
    start_exec = time_perf()
    result = simulator.run(compiled, shots=1024).result()
    end_exec = time_perf()

    return result.get_counts(), end_transpile - start_transpile, end_exec - start_exec, end_exec - start_transpile

# Circuito de codifica√ß√£o de Shor
qc = QuantumCircuit(9, 9)

# Codifica√ß√£o l√≥gica
qc.h(0)
qc.cx(0, 3)
qc.cx(0, 6)
qc.cx(3, 4)
qc.cx(3, 5)
qc.cx(6, 7)
qc.cx(6, 8)
qc.h(0)
qc.h(3)
qc.h(6)

# Simular erro (opcional)
qc.x(4)  # Simula erro de bit-flip em um dos qubits

# Decodifica√ß√£o
qc.h(0)
qc.h(3)
qc.h(6)
qc.cx(6, 7)
qc.cx(6, 8)
qc.cx(3, 4)
qc.cx(3, 5)
qc.cx(0, 3)
qc.cx(0, 6)

# Medi√ß√£o
qc.measure(range(9), range(9))

# Execu√ß√£o
simulator = AerSimulator()
counts, t_transpile, t_exec, t_total = execute_quantum_circuit(qc, simulator)

print("Resultado da Codifica√ß√£o de Shor:", counts)
print(f"Tempo de transpilar: {t_transpile:.6f} segundos")
print(f"Tempo de execu√ß√£o: {t_exec:.6f} segundos")
print(f"Tempo total de execu√ß√£o: {t_total:.6f} segundos")

qc.draw(output='mpl')

```


## Considera√ß√µes Finais {#sec-quant-consid-finais}
Este minicurso teve como objetivo introduzir os fundamentos da computa√ß√£o qu√¢ntica de forma acess√≠vel e pr√°tica, utilizando a biblioteca Qiskit como ferramenta principal. Ao longo dos t√≥picos, exploramos conceitos essenciais da mec√¢nica qu√¢ntica, discutimos diferentes arquiteturas de qubits e mergulhamos em aplica√ß√µes reais que j√° est√£o moldando o futuro da tecnologia.

Mais do que apresentar c√≥digos e teorias, a proposta foi despertar a curiosidade e incentivar o pensamento cr√≠tico sobre as possibilidades e limita√ß√µes dessa √°rea emergente. A computa√ß√£o qu√¢ntica ainda est√° em seus primeiros passos, mas j√° oferece um campo f√©rtil para inova√ß√£o, pesquisa e descobertas.

Espero que este material tenha servido como ponto de partida para quem deseja se aprofundar nesse universo fascinante. Que ele inspire novas ideias, projetos e, quem sabe, futuras contribui√ß√µes para o avan√ßo da ci√™ncia qu√¢ntica.

## Refer√™ncias

1. Qiskit Documentation. IBM Quantum. Dispon√≠vel em: [https://qiskit.org/documentation/](https://qiskit.org/documentation/)

2. R. S. Santos, E. A. Oliveira, "Introdu√ß√£o √† Computa√ß√£o Qu√¢ntica: Conceitos e Aplica√ß√µes", *Revista Brasileira de Ensino de F√≠sica*, vol. 43, 2021. DOI: [10.1590/1806-9126-RBEF-2021-0033](https://doi.org/10.1590/1806-9126-RBEF-2021-0033)
